class g{static async perform(a,r,t,s){return this[a.action]!=null?await this[a.action](a,r,t,s):await this.do_math_api(a,r,t,s)}static async add(a,r,t,s){return await this.do_math(a,r,t,s,(i,c)=>i+c)}static async subtract(a,r,t,s){return await this.do_math(a,r,t,s,(i,c)=>i-c)}static async multiply(a,r,t,s){return await this.do_math(a,r,t,s,(i,c)=>i*c)}static async divide(a,r,t,s){return await this.do_math(a,r,t,s,(i,c)=>i/c)}static async do_math(a,r,t,s,i){const c=await crs.process.getValue(a.args.value1,r,t,s),l=await crs.process.getValue(a.args.value2,r,t,s),u=i(c,l);return a.args.target!=null&&await crs.process.setValue(a.args.target,u,r,t,s),u}static async do_math_api(a,r,t,s){const i=[],c=Array.isArray(a.args.value)?a.args.value:[a.args.value];for(let n of c){const e=await crs.process.getValue(n,r,t,s);i.push(e)}const l=await crs.process.getValue(a.args.action,r,t,s),u=Math[l]?.(...i);return a.args.target!=null&&await crs.process.setValue(a.args.target,u,r,t,s),u}static async normalize(a,r,t,s){const i=await crs.process.getValue(a.args.value,r,t,s),c=await crs.process.getValue(a.args.min,r,t,s),l=await crs.process.getValue(a.args.max,r,t,s),u=Number(((i-c)/(l-c)).toFixed(2));return a.args.target!=null&&await crs.process.setValue(a.args.target,u,r,t,s),u}}crs.intent.math=g;export{g as MathActions};
